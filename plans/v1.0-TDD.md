# Technical Design Document — v1.0 Production
## This Mind Does Not Exist

> **IMPORTANT:** This TDD is only to be implemented AFTER v0.1, v0.2, v0.3, and v0.4 PRDs and TDDs are completed and their features are fully implemented and tested.

---

## Document Metadata

| Field | Value |
|---|---|
| Version | 1.0 |
| Status | Draft |
| Milestone | Production Release |
| Depends On | v0.1, v0.2, v0.3, v0.4 TDDs |
| Authors | Engineering Team |
| Last Updated | 2026-02-27 |

---

## 1. System Context

v1.0 builds on the complete foundation established in v0.1–v0.4. The technical additions in v1.0 are:

1. **Installer toolchain** — Platform-specific packaging and distribution
2. **Responsive UI layer** — CSS/component refactoring + PWA capabilities
3. **Benchmark engine** — New `packages/benchmark` package
4. **Community hub** — New `packages/community` package + `/community` UI routes

### Repository Structure Changes

```
this-mind-does-not-exist/
├── apps/
│   ├── web/                    ← MODIFIED: responsive UI, PWA, community pages, benchmark pages
│   └── cli/                    ← MODIFIED: publish, benchmark commands
├── packages/
│   ├── core/                   ← UNCHANGED (v0.1-v0.4 complete)
│   ├── shared/                 ← MODIFIED: new types for benchmark, community
│   ├── ui/                     ← MODIFIED: responsive components
│   ├── benchmark/              ← NEW: benchmark engine
│   └── community/              ← NEW: community hub client
├── installer/
│   ├── macos/                  ← NEW: macOS installer
│   ├── windows/                ← NEW: Windows installer
│   └── linux/                  ← NEW: Linux installer scripts
├── scripts/
│   ├── build-installers.sh     ← NEW: CI script to build all installers
│   └── ...existing scripts...
└── .github/
    └── workflows/
        ├── release.yml         ← NEW: build and publish installers on tag
        └── benchmark-ci.yml    ← NEW: run benchmark suite in CI
```

---

## 2. Technical Design: One-Click Installer

### 2.1 Technology Choices

| Platform | Installer Technology | Rationale |
|---|---|---|
| macOS | **Tauri** (Rust + WebView) | Native macOS look, code signing support, small binary size, no Electron overhead |
| Windows | **NSIS** (Nullsoft Scriptable Install System) | Industry standard, small footprint, excellent Windows integration |
| Linux | **Bash script** + **FPM** (Effing Package Management) | Universal compatibility; FPM generates .deb and .rpm from same source |

### 2.2 macOS Installer Design

#### 2.2.1 Architecture

```
installer/macos/
├── src-tauri/
│   ├── Cargo.toml
│   ├── tauri.conf.json
│   └── src/
│       ├── main.rs              ← Tauri app entry point
│       ├── installer.rs         ← Core installation logic
│       ├── hardware_check.rs    ← RAM/GPU/disk detection
│       ├── ollama.rs            ← Ollama install/detect
│       └── model_puller.rs      ← Model download with progress
├── src/                         ← Frontend (HTML/CSS/JS for installer UI)
│   ├── index.html
│   ├── installer.js
│   └── styles.css
└── build.sh                     ← Build script
```

#### 2.2.2 Installation Steps (Rust Implementation)

```rust
// installer/macos/src-tauri/src/installer.rs

pub struct InstallerConfig {
    pub install_dir: PathBuf,       // Default: /Applications/TMDE
    pub data_dir: PathBuf,          // Default: ~/Library/Application Support/TMDE
    pub model_tier: ModelTier,      // Full or Lite
}

pub enum ModelTier {
    Full,   // qwen3:32b + llama3.3:70b + nomic-embed-text
    Lite,   // llama3.1:8b + mistral:7b + nomic-embed-text
}

pub async fn run_installation(
    config: InstallerConfig,
    progress_tx: Sender<InstallProgress>,
) -> Result<(), InstallerError> {
    // Step 1: Hardware check
    progress_tx.send(InstallProgress::step("Checking hardware...")).await?;
    let hw = check_hardware()?;
    if hw.ram_gb < 8 {
        progress_tx.send(InstallProgress::warning(
            format!("Only {}GB RAM detected. Minimum 8GB required.", hw.ram_gb)
        )).await?;
    }

    // Step 2: Check/install Ollama
    progress_tx.send(InstallProgress::step("Checking Ollama...")).await?;
    if !is_ollama_installed() {
        install_ollama_macos(&progress_tx).await?;
    }

    // Step 3: Copy TMDE files
    progress_tx.send(InstallProgress::step("Installing TMDE...")).await?;
    copy_app_bundle(&config.install_dir)?;

    // Step 4: Pull models
    let models = config.model_tier.models();
    for model in &models {
        progress_tx.send(InstallProgress::step(
            format!("Downloading {}...", model)
        )).await?;
        pull_model_with_progress(model, &progress_tx).await?;
    }

    // Step 5: Install LaunchAgent
    progress_tx.send(InstallProgress::step("Configuring auto-start...")).await?;
    install_launch_agent(&config)?;

    // Step 6: Open browser
    progress_tx.send(InstallProgress::complete()).await?;
    open_browser("http://localhost:3000")?;

    Ok(())
}
```

#### 2.2.3 LaunchAgent Plist

```xml
<!-- ~/Library/LaunchAgents/com.tmde.backend.plist -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
  "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.tmde.backend</string>
    <key>ProgramArguments</key>
    <array>
        <string>/Applications/TMDE.app/Contents/MacOS/tmde-backend</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>~/Library/Logs/TMDE/backend.log</string>
    <key>StandardErrorPath</key>
    <string>~/Library/Logs/TMDE/backend-error.log</string>
</dict>
</plist>
```

#### 2.2.4 Code Signing and Notarization

```bash
# build.sh (macOS)
# 1. Build Tauri app
cargo tauri build --target universal-apple-darwin

# 2. Sign the app bundle
codesign --deep --force --verify --verbose \
  --sign "Developer ID Application: TMDE Team (XXXXXXXXXX)" \
  --options runtime \
  --entitlements entitlements.plist \
  TMDE.app

# 3. Create DMG
create-dmg \
  --volname "TMDE Installer" \
  --window-pos 200 120 \
  --window-size 800 400 \
  --icon-size 100 \
  --icon "TMDE.app" 200 190 \
  --hide-extension "TMDE.app" \
  --app-drop-link 600 185 \
  "TMDE-v1.0.dmg" \
  "TMDE.app"

# 4. Notarize
xcrun notarytool submit TMDE-v1.0.dmg \
  --apple-id "$APPLE_ID" \
  --password "$APPLE_APP_PASSWORD" \
  --team-id "$TEAM_ID" \
  --wait

# 5. Staple
xcrun stapler staple TMDE-v1.0.dmg
```

### 2.3 Windows Installer Design

#### 2.3.1 NSIS Script Structure

```
installer/windows/
├── tmde-installer.nsi          ← Main NSIS script
├── installer-ui.nsh            ← Custom UI pages
├── hardware-check.nsh          ← Hardware detection
├── ollama-check.nsh            ← Ollama detection/install
├── model-pull.nsh              ← Model download
├── service-install.nsh         ← Windows Service registration
└── assets/
    ├── installer-banner.bmp
    ├── installer-header.bmp
    └── tmde-icon.ico
```

#### 2.3.2 Key NSIS Sections

```nsis
; tmde-installer.nsi

!define PRODUCT_NAME "This Mind Does Not Exist"
!define PRODUCT_VERSION "1.0.0"
!define PRODUCT_PUBLISHER "TMDE Team"
!define PRODUCT_WEB_SITE "https://github.com/lalomax/this-mind-does-not-exist"

; Hardware check page
Page custom HardwareCheckPage HardwareCheckPageLeave

; Model selection page
Page custom ModelSelectionPage ModelSelectionPageLeave

; Standard pages
Page instfiles

Section "Core Installation" SEC_CORE
    SetOutPath "$INSTDIR"
    File /r "dist\*.*"

    ; Install as Windows Service
    ExecWait '"$INSTDIR\nssm.exe" install TMDEBackend "$INSTDIR\tmde-backend.exe"'
    ExecWait '"$INSTDIR\nssm.exe" set TMDEBackend AppDirectory "$INSTDIR"'
    ExecWait '"$INSTDIR\nssm.exe" set TMDEBackend Start SERVICE_AUTO_START'
    ExecWait '"$INSTDIR\nssm.exe" start TMDEBackend'

    ; Create shortcuts
    CreateDirectory "$SMPROGRAMS\${PRODUCT_NAME}"
    CreateShortCut "$SMPROGRAMS\${PRODUCT_NAME}\${PRODUCT_NAME}.lnk" \
        "$INSTDIR\tmde-launcher.exe"
    CreateShortCut "$DESKTOP\${PRODUCT_NAME}.lnk" \
        "$INSTDIR\tmde-launcher.exe"

    ; Write registry
    WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\TMDE" \
        "DisplayName" "${PRODUCT_NAME}"
    WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\TMDE" \
        "UninstallString" "$INSTDIR\uninstall.exe"
SectionEnd

Section "Ollama" SEC_OLLAMA
    ; Check if Ollama is installed
    ReadRegStr $0 HKLM "Software\Ollama" "InstallPath"
    StrCmp $0 "" 0 OllamaAlreadyInstalled
        ; Download and install Ollama
        NSISdl::download "https://ollama.ai/download/OllamaSetup.exe" \
            "$TEMP\OllamaSetup.exe"
        ExecWait '"$TEMP\OllamaSetup.exe" /S'
    OllamaAlreadyInstalled:
SectionEnd
```

### 2.4 Linux Installer Design

#### 2.4.1 Shell Script Structure

```bash
#!/usr/bin/env bash
# installer/linux/install.sh

set -euo pipefail

TMDE_VERSION="1.0.0"
INSTALL_DIR="/opt/tmde"
SERVICE_USER="tmde"
LOG_DIR="/var/log/tmde"

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info()    { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn()    { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error()   { echo -e "${RED}[ERROR]${NC} $1"; }

check_hardware() {
    local ram_gb
    ram_gb=$(free -g | awk '/^Mem:/{print $2}')
    if [ "$ram_gb" -lt 8 ]; then
        log_warn "Only ${ram_gb}GB RAM detected. Minimum 8GB required."
        read -p "Continue anyway? [y/N] " -n 1 -r
        echo
        [[ $REPLY =~ ^[Yy]$ ]] || exit 1
    fi
    log_info "Hardware check passed: ${ram_gb}GB RAM"
}

install_ollama() {
    if command -v ollama &>/dev/null; then
        log_info "Ollama already installed: $(ollama --version)"
        return
    fi
    log_info "Installing Ollama..."
    curl -fsSL https://ollama.ai/install.sh | sh
}

pull_models() {
    local tier="${1:-full}"
    if [ "$tier" = "full" ]; then
        local models=("qwen3:32b" "llama3.3:70b" "nomic-embed-text")
    else
        local models=("llama3.1:8b" "mistral:7b" "nomic-embed-text")
    fi

    for model in "${models[@]}"; do
        log_info "Pulling model: $model"
        ollama pull "$model"
    done
}

install_systemd_service() {
    cat > /etc/systemd/system/tmde.service << EOF
[Unit]
Description=This Mind Does Not Exist Backend
After=network.target ollama.service

[Service]
Type=simple
User=${SERVICE_USER}
WorkingDirectory=${INSTALL_DIR}
ExecStart=${INSTALL_DIR}/bin/tmde-backend
Restart=always
RestartSec=5
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable tmde
    systemctl start tmde
}

main() {
    log_info "Installing This Mind Does Not Exist v${TMDE_VERSION}"
    check_hardware
    install_ollama

    # Model tier selection
    echo "Select model tier:"
    echo "  1) Full  (qwen3:32b + llama3.3:70b, requires 48GB+ RAM)"
    echo "  2) Lite  (llama3.1:8b + mistral:7b, requires 12GB+ RAM)"
    read -p "Choice [1/2]: " -n 1 -r tier_choice
    echo
    [ "$tier_choice" = "2" ] && MODEL_TIER="lite" || MODEL_TIER="full"

    pull_models "$MODEL_TIER"
    install_systemd_service

    log_info "Installation complete!"
    log_info "Open http://localhost:3000 in your browser"
    xdg-open "http://localhost:3000" 2>/dev/null || true
}

main "$@"
```

#### 2.4.2 Package Building with FPM

```bash
# scripts/build-linux-packages.sh

VERSION="1.0.0"

# Build .deb
fpm -s dir -t deb \
  --name tmde \
  --version "$VERSION" \
  --architecture amd64 \
  --description "This Mind Does Not Exist - Local AI Reasoning Engine" \
  --url "https://github.com/lalomax/this-mind-does-not-exist" \
  --maintainer "TMDE Team <team@tmde.ai>" \
  --depends "curl" \
  --depends "nodejs (>= 20)" \
  --after-install installer/linux/postinstall.sh \
  --before-remove installer/linux/preremove.sh \
  dist/=/opt/tmde/ \
  installer/linux/tmde.service=/etc/systemd/system/tmde.service

# Build .rpm
fpm -s dir -t rpm \
  --name tmde \
  --version "$VERSION" \
  --architecture x86_64 \
  --description "This Mind Does Not Exist - Local AI Reasoning Engine" \
  --url "https://github.com/lalomax/this-mind-does-not-exist" \
  --maintainer "TMDE Team <team@tmde.ai>" \
  --depends "curl" \
  --depends "nodejs >= 20" \
  --after-install installer/linux/postinstall.sh \
  --before-remove installer/linux/preremove.sh \
  dist/=/opt/tmde/ \
  installer/linux/tmde.service=/etc/systemd/system/tmde.service
```

### 2.5 CI/CD Pipeline for Installers

```yaml
# .github/workflows/release.yml

name: Build and Release Installers

on:
  push:
    tags:
      - 'v*'

jobs:
  build-macos:
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin,x86_64-apple-darwin
      - name: Install Tauri CLI
        run: cargo install tauri-cli
      - name: Build universal macOS installer
        run: cd installer/macos && cargo tauri build --target universal-apple-darwin
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          TEAM_ID: ${{ secrets.TEAM_ID }}
      - name: Upload DMG
        uses: actions/upload-artifact@v4
        with:
          name: macos-installer
          path: installer/macos/target/release/bundle/dmg/*.dmg

  build-windows:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install NSIS
        run: choco install nsis
      - name: Build Windows installer
        run: makensis installer/windows/tmde-installer.nsi
      - name: Sign installer
        run: |
          signtool sign /f cert.pfx /p ${{ secrets.WINDOWS_CERT_PASSWORD }} \
            /tr http://timestamp.digicert.com /td sha256 /fd sha256 \
            installer/windows/TMDE-Setup.exe
      - name: Upload EXE
        uses: actions/upload-artifact@v4
        with:
          name: windows-installer
          path: installer/windows/TMDE-Setup.exe

  build-linux:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - name: Install FPM
        run: gem install fpm
      - name: Build packages
        run: bash scripts/build-linux-packages.sh
      - name: Upload packages
        uses: actions/upload-artifact@v4
        with:
          name: linux-packages
          path: |
            *.deb
            *.rpm
            installer/linux/install.sh

  create-release:
    needs: [build-macos, build-windows, build-linux]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            macos-installer/*.dmg
            windows-installer/*.exe
            linux-packages/*.deb
            linux-packages/*.rpm
            linux-packages/install.sh
```

### 2.6 Hardware Detection Module

```typescript
// packages/core/src/system/hardware-detector.ts

export interface HardwareInfo {
  ramGb: number;
  cpuCores: number;
  gpuVramGb: number | null;
  gpuType: 'nvidia' | 'amd' | 'apple-silicon' | 'intel-arc' | 'none';
  diskFreeGb: number;
  platform: 'darwin' | 'win32' | 'linux';
  arch: 'x64' | 'arm64';
}

export interface HardwareRequirements {
  minRamGb: number;
  recommendedRamGb: number;
  minDiskFreeGb: number;
  gpuRequired: boolean;
}

export const MODEL_TIER_REQUIREMENTS: Record<string, HardwareRequirements> = {
  full: {
    minRamGb: 32,
    recommendedRamGb: 48,
    minDiskFreeGb: 80,
    gpuRequired: false,
  },
  lite: {
    minRamGb: 8,
    recommendedRamGb: 16,
    minDiskFreeGb: 30,
    gpuRequired: false,
  },
};

export async function detectHardware(): Promise<HardwareInfo> {
  // Implementation uses os module + platform-specific commands
  // (sysctl on macOS, /proc/meminfo on Linux, wmic on Windows)
}

export function validateHardware(
  hw: HardwareInfo,
  requirements: HardwareRequirements
): { passes: boolean; warnings: string[]; errors: string[] } {
  // Returns validation result with human-readable messages
}
```

---

## 3. Technical Design: Mobile-Responsive UI

### 3.1 Responsive Architecture

The existing Next.js 15 app uses Tailwind CSS. The responsive refactor follows a **mobile-first** approach: base styles target mobile, with `md:` and `lg:` prefixes for larger screens.

#### 3.1.1 Breakpoint System

```typescript
// tailwind.config.ts (updated)
export default {
  theme: {
    screens: {
      'sm': '480px',   // Large phones (landscape)
      'md': '768px',   // Tablets
      'lg': '1024px',  // Desktop
      'xl': '1280px',  // Large desktop
      '2xl': '1536px', // Ultra-wide
    },
  },
}
```

#### 3.1.2 Layout Component

```typescript
// apps/web/app/components/layout/AppLayout.tsx

export function AppLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="min-h-screen bg-background">
      {/* Mobile: bottom nav; Desktop: top nav */}
      <nav className="hidden lg:flex fixed top-0 w-full z-50 ...">
        <DesktopNav />
      </nav>
      <nav className="flex lg:hidden fixed bottom-0 w-full z-50 ...">
        <MobileBottomNav />
      </nav>

      {/* Content area with appropriate padding */}
      <main className="
        pt-0 pb-16          /* Mobile: no top padding, bottom padding for nav */
        lg:pt-16 lg:pb-0    /* Desktop: top padding for nav, no bottom padding */
        px-4 md:px-6 lg:px-8
      ">
        {children}
      </main>
    </div>
  );
}
```

### 3.2 Debate Viewer Responsive Design

```typescript
// apps/web/app/components/debate/DebateViewer.tsx

export function DebateViewer({ debate }: { debate: DebateState }) {
  return (
    <div className="w-full">
      {/* Round progress indicator */}
      <RoundIndicator
        currentRound={debate.currentRound}
        totalRounds={debate.config.maxRounds}
        className="mb-4"
      />

      {/* Mobile: stacked; Desktop: side-by-side */}
      <div className="
        flex flex-col gap-4
        lg:grid lg:grid-cols-2 lg:gap-6
      ">
        {debate.rounds.map((round) => (
          <RoundCard
            key={round.number}
            round={round}
            className="w-full"
          />
        ))}
      </div>

      {/* Final answer - always full width */}
      {debate.finalAnswer && (
        <FinalAnswer
          answer={debate.finalAnswer}
          className="mt-6 w-full"
        />
      )}
    </div>
  );
}
```

### 3.3 Touch-Optimized Components

```typescript
// apps/web/app/components/ui/RatingWidget.tsx

export function RatingWidget({
  value,
  onChange,
}: {
  value: number;
  onChange: (v: number) => void;
}) {
  return (
    <div className="flex gap-2">
      {[1, 2, 3, 4, 5].map((star) => (
        <button
          key={star}
          onClick={() => onChange(star * 2)} // Map 1-5 stars to 1-10 scale
          className="
            w-11 h-11          /* 44px minimum touch target */
            flex items-center justify-center
            rounded-full
            transition-colors
            touch-manipulation  /* Disable double-tap zoom */
          "
          aria-label={`Rate ${star * 2} out of 10`}
        >
          <StarIcon
            className={cn(
              "w-6 h-6",
              star * 2 <= value ? "text-yellow-400" : "text-gray-300"
            )}
          />
        </button>
      ))}
    </div>
  );
}
```

### 3.4 PWA Configuration

```typescript
// apps/web/next.config.js (updated)
const withPWA = require('next-pwa')({
  dest: 'public',
  register: true,
  skipWaiting: true,
  runtimeCaching: [
    {
      urlPattern: /^https?.*/,
      handler: 'NetworkFirst',
      options: {
        cacheName: 'tmde-cache',
        expiration: {
          maxEntries: 200,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        },
      },
    },
  ],
  buildExcludes: [/middleware-manifest\.json$/],
});

module.exports = withPWA({
  // existing config
});
```

```json
// apps/web/public/manifest.json
{
  "name": "This Mind Does Not Exist",
  "short_name": "TMDE",
  "description": "Local AI reasoning engine with adversarial debate",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#0f0f1a",
  "theme_color": "#e94560",
  "orientation": "any",
  "icons": [
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}
```

### 3.5 Mobile Navigation

```typescript
// apps/web/app/components/layout/MobileBottomNav.tsx

const NAV_ITEMS = [
  { href: '/',          icon: HomeIcon,      label: 'Reason'    },
  { href: '/traces',    icon: HistoryIcon,   label: 'History'   },
  { href: '/community', icon: UsersIcon,     label: 'Community' },
  { href: '/benchmark', icon: ChartBarIcon,  label: 'Benchmark' },
  { href: '/settings',  icon: SettingsIcon,  label: 'Settings'  },
];

export function MobileBottomNav() {
  const pathname = usePathname();

  return (
    <nav className="
      flex items-center justify-around
      bg-background/95 backdrop-blur
      border-t border-border
      h-16 px-2
      safe-area-inset-bottom  /* iOS safe area */
    ">
      {NAV_ITEMS.map(({ href, icon: Icon, label }) => (
        <Link
          key={href}
          href={href}
          className={cn(
            "flex flex-col items-center gap-1 px-3 py-2 rounded-lg",
            "min-w-[44px] min-h-[44px]",  /* Touch target */
            "transition-colors",
            pathname === href
              ? "text-primary"
              : "text-muted-foreground hover:text-foreground"
          )}
        >
          <Icon className="w-5 h-5" />
          <span className="text-xs font-medium">{label}</span>
        </Link>
      ))}
    </nav>
  );
}
```

### 3.6 Performance Optimizations for Mobile

```typescript
// apps/web/app/components/debate/StreamingText.tsx
// Optimized for mobile: batches DOM updates to prevent layout thrash

export function StreamingText({ stream }: { stream: ReadableStream<string> }) {
  const [text, setText] = useState('');
  const bufferRef = useRef('');
  const rafRef = useRef<number>();

  useEffect(() => {
    const reader = stream.getReader();

    const flush = () => {
      if (bufferRef.current) {
        setText(prev => prev + bufferRef.current);
        bufferRef.current = '';
      }
      rafRef.current = requestAnimationFrame(flush);
    };

    rafRef.current = requestAnimationFrame(flush);

    const read = async () => {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        bufferRef.current += value; // Buffer chunks
      }
    };

    read();

    return () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      reader.cancel();
    };
  }, [stream]);

  return <div className="prose prose-sm max-w-none">{text}</div>;
}
```

---

## 4. Technical Design: Benchmark Suite

### 4.1 Package Structure

```
packages/benchmark/
├── package.json
├── src/
│   ├── index.ts                 ← Public API
│   ├── runner.ts                ← Benchmark runner
│   ├── scorer.ts                ← Scoring engine
│   ├── reporter.ts              ← Results reporting
│   ├── questions/
│   │   ├── index.ts             ← Question loader
│   │   ├── math.ts              ← Math questions
│   │   ├── science.ts           ← Science questions
│   │   ├── logic.ts             ← Logic questions
│   │   ├── coding.ts            ← Coding questions
│   │   └── research.ts          ← Research questions
│   └── reference/
│       ├── gpt4o.json           ← Pre-computed GPT-4o scores
│       ├── claude-opus.json     ← Pre-computed Claude Opus scores
│       └── grok4.json           ← Pre-computed Grok-4 scores
├── data/
│   ├── math/                    ← Math question files (JSONL)
│   ├── science/                 ← Science question files (JSONL)
│   ├── logic/                   ← Logic question files (JSONL)
│   ├── coding/                  ← Coding question files (JSONL)
│   └── research/                ← Research question files (JSONL)
└── tests/
    ├── runner.test.ts
    ├── scorer.test.ts
    └── fixtures/
```

### 4.2 Question Format

```typescript
// packages/benchmark/src/questions/types.ts

export interface BenchmarkQuestion {
  id: string;                    // e.g., "math-001"
  domain: BenchmarkDomain;
  difficulty: 'easy' | 'medium' | 'hard' | 'expert';
  question: string;
  referenceAnswer?: string;      // For open-ended questions
  groundTruth?: string;          // For exact-match questions
  testCases?: TestCase[];        // For coding questions
  rubric?: EvaluationRubric;
  source?: string;               // Citation
  checksum: string;              // SHA-256 of question text (for versioning)
}

export interface TestCase {
  input: string;
  expectedOutput: string;
  isPublic: boolean;             // Public test cases shown to model
}

export interface EvaluationRubric {
  criteria: RubricCriterion[];
  maxScore: number;
}

export interface RubricCriterion {
  name: string;
  description: string;
  maxPoints: number;
  scoringGuide: string;
}

export type BenchmarkDomain =
  | 'mathematics'
  | 'science'
  | 'logic'
  | 'coding'
  | 'research';
```

### 4.3 Benchmark Runner

```typescript
// packages/benchmark/src/runner.ts

export interface BenchmarkConfig {
  suite: 'quick' | 'full' | 'custom';
  domains?: BenchmarkDomain[];
  questionsPerDomain?: number;   // Default: 10 (quick) or 50 (full)
  runsPerQuestion?: number;      // Default: 3
  seed?: number;                 // For reproducibility
  tmdeConfig: DebateConfig;      // Passed to debate engine
  outputPath?: string;           // Where to save results
  resumeFrom?: string;           // Resume from a previous run
}

export interface BenchmarkResult {
  runId: string;
  startedAt: Date;
  completedAt: Date;
  config: BenchmarkConfig;
  systemInfo: HardwareInfo;
  results: QuestionResult[];
  summary: BenchmarkSummary;
}

export interface QuestionResult {
  questionId: string;
  domain: BenchmarkDomain;
  runs: RunResult[];
  meanScore: number;
  stdDev: number;
  confidenceInterval: [number, number]; // 95% CI
}

export interface RunResult {
  runNumber: number;
  answer: string;
  score: number;
  scoringDetails: ScoringDetails;
  durationMs: number;
  traceId: string;
}

export class BenchmarkRunner {
  constructor(
    private readonly debateEngine: DebateOrchestrator,
    private readonly scorer: BenchmarkScorer,
    private readonly db: BenchmarkDatabase,
  ) {}

  async run(
    config: BenchmarkConfig,
    onProgress: (progress: BenchmarkProgress) => void,
  ): Promise<BenchmarkResult> {
    const runId = generateId();
    const questions = await this.loadQuestions(config);

    // Resume support: skip already-completed questions
    const completed = config.resumeFrom
      ? await this.db.getCompletedQuestions(config.resumeFrom)
      : new Set<string>();

    const results: QuestionResult[] = [];

    for (const question of questions) {
      if (completed.has(question.id)) {
        onProgress({ type: 'skip', questionId: question.id });
        continue;
      }

      const runs: RunResult[] = [];

      for (let run = 1; run <= (config.runsPerQuestion ?? 3); run++) {
        onProgress({
          type: 'running',
          questionId: question.id,
          run,
          totalRuns: config.runsPerQuestion ?? 3,
        });

        const debate = await this.debateEngine.run(question.question, {
          ...config.tmdeConfig,
          seed: config.seed ? config.seed + run : undefined,
        });

        const scoring = await this.scorer.score(question, debate.finalAnswer);

        runs.push({
          runNumber: run,
          answer: debate.finalAnswer,
          score: scoring.totalScore,
          scoringDetails: scoring,
          durationMs: debate.durationMs,
          traceId: debate.traceId,
        });

        // Save incrementally for resume support
        await this.db.saveRunResult(runId, question.id, run, runs[run - 1]);
      }

      const questionResult = this.aggregateRuns(question, runs);
      results.push(questionResult);
    }

    const summary = this.computeSummary(results);
    const result: BenchmarkResult = {
      runId,
      startedAt: new Date(),
      completedAt: new Date(),
      config,
      systemInfo: await detectHardware(),
      results,
      summary,
    };

    await this.db.saveBenchmarkResult(result);
    return result;
  }

  private aggregateRuns(
    question: BenchmarkQuestion,
    runs: RunResult[],
  ): QuestionResult {
    const scores = runs.map(r => r.score);
    const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
    const variance = scores.reduce((a, b) => a + (b - mean) ** 2, 0) / scores.length;
    const stdDev = Math.sqrt(variance);
    const ci = bootstrapCI(scores, 0.95);

    return {
      questionId: question.id,
      domain: question.domain,
      runs,
      meanScore: mean,
      stdDev,
      confidenceInterval: ci,
    };
  }
}
```

### 4.4 Scoring Engine

```typescript
// packages/benchmark/src/scorer.ts

export class BenchmarkScorer {
  constructor(
    private readonly ollamaClient: OllamaClient,
    private readonly judgeModel: string = 'llama3.3:70b',
  ) {}

  async score(
    question: BenchmarkQuestion,
    answer: string,
  ): Promise<ScoringDetails> {
    if (question.testCases) {
      // Coding: run test cases
      return this.scoreWithTestCases(question, answer);
    }

    if (question.groundTruth) {
      // Math with exact answer: check for correct answer in response
      return this.scoreExactMatch(question, answer);
    }

    // Open-ended: LLM judge
    return this.scoreWithJudge(question, answer);
  }

  private async scoreWithJudge(
    question: BenchmarkQuestion,
    answer: string,
  ): Promise<ScoringDetails> {
    const rubric = question.rubric ?? DEFAULT_RUBRIC;

    const judgePrompt = `
You are an expert evaluator. Score the following answer to the question using the provided rubric.

QUESTION:
${question.question}

${question.referenceAnswer ? `REFERENCE ANSWER:\n${question.referenceAnswer}\n` : ''}

ANSWER TO EVALUATE:
${answer}

RUBRIC:
${rubric.criteria.map(c => `- ${c.name} (0-${c.maxPoints}): ${c.description}`).join('\n')}

Respond with a JSON object:
{
  "scores": {
    "${rubric.criteria.map(c => c.name).join('": <score>, "')}: <score>
  },
  "reasoning": "<brief explanation>",
  "totalScore": <sum of all scores>
}
`;

    const response = await this.ollamaClient.generate({
      model: this.judgeModel,
      prompt: judgePrompt,
      format: 'json',
    });

    return JSON.parse(response.response);
  }
}

const DEFAULT_RUBRIC: EvaluationRubric = {
  maxScore: 10,
  criteria: [
    {
      name: 'accuracy',
      description: 'Is the answer factually correct?',
      maxPoints: 3,
      scoringGuide: '3=fully correct, 2=mostly correct, 1=partially correct, 0=incorrect',
    },
    {
      name: 'completeness',
      description: 'Does it address all aspects of the question?',
      maxPoints: 2,
      scoringGuide: '2=fully complete, 1=partially complete, 0=incomplete',
    },
    {
      name: 'reasoning',
      description: 'Is the reasoning chain sound and well-structured?',
      maxPoints: 2,
      scoringGuide: '2=excellent reasoning, 1=adequate reasoning, 0=poor reasoning',
    },
    {
      name: 'clarity',
      description: 'Is the answer clear and well-organized?',
      maxPoints: 2,
      scoringGuide: '2=very clear, 1=somewhat clear, 0=unclear',
    },
    {
      name: 'depth',
      description: 'Does it demonstrate genuine understanding?',
      maxPoints: 1,
      scoringGuide: '1=demonstrates deep understanding, 0=surface level only',
    },
  ],
};
```

### 4.5 Benchmark Dashboard (Web UI)

```typescript
// apps/web/app/benchmark/page.tsx

export default async function BenchmarkPage() {
  const latestResult = await getBenchmarkResults({ limit: 1 });
  const referenceScores = await getReferenceScores();

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Benchmark Results</h1>

      {/* Radar chart: TMDE vs frontier models */}
      <BenchmarkRadarChart
        tmde={latestResult?.summary.byDomain}
        reference={referenceScores}
        className="mb-8"
      />

      {/* Per-domain bar chart */}
      <DomainBarChart
        results={latestResult?.summary.byDomain}
        className="mb-8"
      />

      {/* Historical trend */}
      <BenchmarkTrendChart className="mb-8" />

      {/* Run benchmark button */}
      <RunBenchmarkButton />

      {/* Results table */}
      <BenchmarkResultsTable results={latestResult?.results} />
    </div>
  );
}
```

### 4.6 Statistical Utilities

```typescript
// packages/benchmark/src/stats.ts

/**
 * Bootstrap confidence interval using percentile method
 */
export function bootstrapCI(
  samples: number[],
  confidence: number = 0.95,
  iterations: number = 10000,
): [number, number] {
  const bootstrapMeans: number[] = [];

  for (let i = 0; i < iterations; i++) {
    const resample = Array.from(
      { length: samples.length },
      () => samples[Math.floor(Math.random() * samples.length)]
    );
    bootstrapMeans.push(resample.reduce((a, b) => a + b, 0) / resample.length);
  }

  bootstrapMeans.sort((a, b) => a - b);
  const alpha = 1 - confidence;
  const lower = bootstrapMeans[Math.floor(alpha / 2 * iterations)];
  const upper = bootstrapMeans[Math.floor((1 - alpha / 2) * iterations)];

  return [lower, upper];
}

/**
 * Wilcoxon signed-rank test for paired samples
 * Returns p-value
 */
export function wilcoxonSignedRank(
  sample1: number[],
  sample2: number[],
): number {
  // Implementation of Wilcoxon signed-rank test
  // Returns p-value for H0: median difference = 0
}
```

---

## 5. Technical Design: Community Hub

### 5.1 Package Structure

```
packages/community/
├── package.json
├── src/
│   ├── index.ts                 ← Public API
│   ├── registry-client.ts       ← GitHub registry client
│   ├── template-publisher.ts    ← Template publishing
│   ├── lora-publisher.ts        ← LoRA adapter publishing
│   ├── downloader.ts            ← Download with progress
│   ├── validator.ts             ← Content validation
│   └── cache.ts                 ← Local cache management
└── tests/
    ├── registry-client.test.ts
    ├── validator.test.ts
    └── fixtures/
```

### 5.2 Registry Format

```json
// Community registry (GitHub repo: tmde-community/registry)
// registry.json

{
  "version": "1",
  "lastUpdated": "2026-02-27T00:00:00Z",
  "templates": [
    {
      "id": "socratic-questioning-v1",
      "name": "Socratic Questioning",
      "author": "community-user-1",
      "authorUrl": "https://github.com/community-user-1",
      "version": "1.0.0",
      "domain": "philosophy",
      "complexity": "moderate",
      "methodology": "dialectical",
      "keywords": ["socratic", "questioning", "dialogue", "philosophy"],
      "description": "Template for Socratic method of inquiry through questioning",
      "downloadUrl": "https://gist.github.com/community-user-1/abc123/raw/template.md",
      "checksum": "sha256:abc123...",
      "rating": 4.7,
      "ratingCount": 23,
      "downloadCount": 156,
      "publishedAt": "2026-01-15T00:00:00Z",
      "updatedAt": "2026-01-20T00:00:00Z",
      "license": "MIT"
    }
  ],
  "loras": [
    {
      "id": "math-reasoning-lora-v2",
      "name": "Math Reasoning LoRA",
      "author": "community-user-2",
      "authorUrl": "https://github.com/community-user-2",
      "version": "2.0.0",
      "baseModel": "qwen3:32b",
      "domain": "mathematics",
      "description": "LoRA adapter fine-tuned on 500+ high-quality math debate traces",
      "huggingFaceRepo": "community-user-2/tmde-math-reasoning-lora",
      "checksum": "sha256:def456...",
      "sizeMb": 128,
      "rating": 4.9,
      "ratingCount": 47,
      "downloadCount": 312,
      "benchmarkScore": 8.7,
      "publishedAt": "2026-01-10T00:00:00Z",
      "updatedAt": "2026-02-01T00:00:00Z",
      "license": "Apache-2.0"
    }
  ]
}
```

### 5.3 Registry Client

```typescript
// packages/community/src/registry-client.ts

const REGISTRY_URL =
  'https://raw.githubusercontent.com/tmde-community/registry/main/registry.json';

export class RegistryClient {
  private cache: RegistryCache;

  constructor(private readonly cacheDir: string) {
    this.cache = new RegistryCache(cacheDir);
  }

  async fetchRegistry(forceRefresh = false): Promise<Registry> {
    if (!forceRefresh) {
      const cached = await this.cache.get('registry');
      if (cached && !this.isStale(cached)) {
        return cached.data;
      }
    }

    const response = await fetch(REGISTRY_URL, {
      headers: { 'Cache-Control': 'no-cache' },
    });

    if (!response.ok) {
      // Fall back to cached version if available
      const cached = await this.cache.get('registry');
      if (cached) return cached.data;
      throw new Error(`Failed to fetch registry: ${response.status}`);
    }

    const registry: Registry = await response.json();
    await this.cache.set('registry', registry);
    return registry;
  }

  async searchTemplates(query: SearchQuery): Promise<TemplateEntry[]> {
    const registry = await this.fetchRegistry();
    return registry.templates
      .filter(t => this.matchesQuery(t, query))
      .sort((a, b) => this.sortScore(b, query.sort) - this.sortScore(a, query.sort));
  }

  async downloadTemplate(
    entry: TemplateEntry,
    destDir: string,
    onProgress: (progress: DownloadProgress) => void,
  ): Promise<string> {
    const response = await fetch(entry.downloadUrl);
    const content = await response.text();

    // Verify checksum
    const checksum = await sha256(content);
    if (checksum !== entry.checksum.replace('sha256:', '')) {
      throw new Error('Checksum mismatch — template may be corrupted');
    }

    const destPath = path.join(destDir, `${entry.id}.md`);
    await fs.writeFile(destPath, content, 'utf-8');

    onProgress({ type: 'complete', path: destPath });
    return destPath;
  }

  async downloadLoRA(
    entry: LoRAEntry,
    destDir: string,
    onProgress: (progress: DownloadProgress) => void,
  ): Promise<string> {
    // Download from Hugging Face Hub
    const hfUrl = `https://huggingface.co/${entry.huggingFaceRepo}/resolve/main/adapter_model.safetensors`;

    const response = await fetch(hfUrl);
    const totalBytes = parseInt(response.headers.get('content-length') ?? '0');
    let downloadedBytes = 0;

    const destPath = path.join(destDir, `${entry.id}.safetensors`);
    const writer = fs.createWriteStream(destPath);

    for await (const chunk of response.body!) {
      writer.write(chunk);
      downloadedBytes += chunk.length;
      onProgress({
        type: 'progress',
        downloaded: downloadedBytes,
        total: totalBytes,
        percent: (downloadedBytes / totalBytes) * 100,
      });
    }

    writer.end();
    return destPath;
  }
}
```

### 5.4 Template Publisher

```typescript
// packages/community/src/template-publisher.ts

export class TemplatePublisher {
  constructor(
    private readonly githubToken: string,
    private readonly validator: ContentValidator,
  ) {}

  async publish(templatePath: string): Promise<PublishResult> {
    // 1. Read and validate template
    const content = await fs.readFile(templatePath, 'utf-8');
    const validation = await this.validator.validateTemplate(content);

    if (!validation.valid) {
      throw new ValidationError(validation.errors);
    }

    const metadata = validation.metadata!;

    // 2. Create GitHub Gist
    const gist = await this.createGist(metadata.name, content);

    // 3. Generate registry entry
    const entry: TemplateEntry = {
      id: slugify(metadata.name) + '-v' + metadata.version,
      name: metadata.name,
      author: await this.getGitHubUsername(),
      authorUrl: `https://github.com/${await this.getGitHubUsername()}`,
      version: metadata.version,
      domain: metadata.domain,
      complexity: metadata.complexity,
      methodology: metadata.methodology,
      keywords: metadata.keywords,
      description: metadata.description,
      downloadUrl: gist.rawUrl,
      checksum: `sha256:${await sha256(content)}`,
      rating: 0,
      ratingCount: 0,
      downloadCount: 0,
      publishedAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      license: metadata.license ?? 'MIT',
    };

    // 4. Submit PR to community registry
    const prUrl = await this.submitRegistryPR(entry);

    return {
      gistUrl: gist.url,
      prUrl,
      entry,
    };
  }

  private async createGist(name: string, content: string): Promise<GistResult> {
    const response = await fetch('https://api.github.com/gists', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${this.githubToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        description: `TMDE Reasoning Template: ${name}`,
        public: true,
        files: {
          'template.md': { content },
        },
      }),
    });

    const gist = await response.json();
    return {
      id: gist.id,
      url: gist.html_url,
      rawUrl: gist.files['template.md'].raw_url,
    };
  }
}
```

### 5.5 Community Hub UI

```typescript
// apps/web/app/community/page.tsx

export default async function CommunityPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-2">Community Hub</h1>
      <p className="text-muted-foreground mb-8">
        Discover and share reasoning templates and LoRA adapters
      </p>

      <Tabs defaultValue="templates">
        <TabsList className="mb-6">
          <TabsTrigger value="templates">Templates</TabsTrigger>
          <TabsTrigger value="loras">LoRA Adapters</TabsTrigger>
        </TabsList>

        <TabsContent value="templates">
          <CommunitySearch type="templates" />
          <Suspense fallback={<TemplateGridSkeleton />}>
            <TemplateGrid />
          </Suspense>
        </TabsContent>

        <TabsContent value="loras">
          <CommunitySearch type="loras" />
          <Suspense fallback={<LoRAGridSkeleton />}>
            <LoRAGrid />
          </Suspense>
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

```typescript
// apps/web/app/community/components/TemplateCard.tsx

export function TemplateCard({ template }: { template: TemplateEntry }) {
  const [installing, setInstalling] = useState(false);

  const handleInstall = async () => {
    setInstalling(true);
    try {
      await installTemplate(template.id);
      toast.success(`"${template.name}" installed successfully`);
    } catch (error) {
      toast.error(`Failed to install: ${error.message}`);
    } finally {
      setInstalling(false);
    }
  };

  return (
    <Card className="flex flex-col h-full">
      <CardHeader>
        <div className="flex items-start justify-between gap-2">
          <CardTitle className="text-base leading-tight">{template.name}</CardTitle>
          <Badge variant="outline">{template.domain}</Badge>
        </div>
        <CardDescription className="line-clamp-2">
          {template.description}
        </CardDescription>
      </CardHeader>

      <CardContent className="flex-1">
        <div className="flex flex-wrap gap-1 mb-3">
          {template.keywords.slice(0, 4).map(kw => (
            <Badge key={kw} variant="secondary" className="text-xs">{kw}</Badge>
          ))}
        </div>

        <div className="flex items-center gap-4 text-sm text-muted-foreground">
          <StarRating value={template.rating} readonly size="sm" />
          <span>{template.downloadCount} downloads</span>
        </div>
      </CardContent>

      <CardFooter className="gap-2">
        <Button
          variant="outline"
          size="sm"
          asChild
          className="flex-1"
        >
          <Link href={`/community/templates/${template.id}`}>Details</Link>
        </Button>
        <Button
          size="sm"
          className="flex-1"
          onClick={handleInstall}
          disabled={installing}
        >
          {installing ? (
            <><Spinner className="mr-2 h-4 w-4" /> Installing...</>
          ) : (
            <><DownloadIcon className="mr-2 h-4 w-4" /> Install</>
          )}
        </Button>
      </CardFooter>
    </Card>
  );
}
```

### 5.6 Content Validator

```typescript
// packages/community/src/validator.ts

import { z } from 'zod';
import matter from 'gray-matter';

const TemplateMetadataSchema = z.object({
  name: z.string().min(3).max(100),
  domain: z.string().min(2).max(50),
  complexity: z.enum(['simple', 'moderate', 'complex', 'expert']),
  methodology: z.string().min(2).max(50),
  keywords: z.array(z.string()).min(1).max(20),
  description: z.string().min(10).max(500),
  version: z.string().regex(/^\d+\.\d+\.\d+$/),
  license: z.string().optional().default('MIT'),
});

export class ContentValidator {
  async validateTemplate(content: string): Promise<ValidationResult> {
    const errors: string[] = [];

    // Parse frontmatter
    let parsed: ReturnType<typeof matter>;
    try {
      parsed = matter(content);
    } catch (e) {
      return { valid: false, errors: ['Invalid YAML frontmatter'] };
    }

    // Validate metadata schema
    const metaResult = TemplateMetadataSchema.safeParse(parsed.data);
    if (!metaResult.success) {
      errors.push(...metaResult.error.errors.map(e => `${e.path}: ${e.message}`));
    }

    // Validate content
    if (parsed.content.trim().length < 100) {
      errors.push('Template content is too short (minimum 100 characters)');
    }

    if (content.length > 50 * 1024) {
      errors.push('Template exceeds 50KB size limit');
    }

    // Check for executable code (security)
    if (this.containsExecutableCode(parsed.content)) {
      errors.push('Templates must not contain executable code');
    }

    return {
      valid: errors.length === 0,
      errors,
      metadata: metaResult.success ? metaResult.data : undefined,
    };
  }

  private containsExecutableCode(content: string): boolean {
    // Check for script tags, eval, exec, etc.
    const dangerousPatterns = [
      /<script/i,
      /eval\s*\(/,
      /exec\s*\(/,
      /require\s*\(/,
      /import\s+/,
      /process\./,
      /child_process/,
    ];
    return dangerousPatterns.some(p => p.test(content));
  }
}
```

### 5.7 New API Endpoints

```typescript
// packages/core/src/server/routes/community.ts

// GET /api/community/templates
// Query params: search, domain, sort, page, limit
router.get('/community/templates', async (req, reply) => {
  const { search, domain, sort = 'downloads', page = 1, limit = 20 } = req.query;
  const registry = await registryClient.fetchRegistry();
  const results = await registryClient.searchTemplates({ search, domain, sort });
  const paginated = paginate(results, page, limit);
  return reply.send(paginated);
});

// POST /api/community/templates/:id/install
router.post('/community/templates/:id/install', async (req, reply) => {
  const { id } = req.params;
  const registry = await registryClient.fetchRegistry();
  const entry = registry.templates.find(t => t.id === id);
  if (!entry) return reply.status(404).send({ error: 'Template not found' });

  const destPath = await registryClient.downloadTemplate(
    entry,
    config.templatesDir,
    (progress) => req.server.io.emit('install-progress', progress),
  );

  // Re-index RAG
  await ragRetriever.reindex();

  return reply.send({ success: true, path: destPath });
});

// GET /api/community/loras
router.get('/community/loras', async (req, reply) => {
  const { search, domain, sort = 'downloads', page = 1, limit = 20 } = req.query;
  const registry = await registryClient.fetchRegistry();
  const results = await registryClient.searchLoRAs({ search, domain, sort });
  return reply.send(paginate(results, page, limit));
});

// POST /api/community/loras/:id/install
router.post('/community/loras/:id/install', async (req, reply) => {
  const { id } = req.params;
  const registry = await registryClient.fetchRegistry();
  const entry = registry.loras.find(l => l.id === id);
  if (!entry) return reply.status(404).send({ error: 'LoRA not found' });

  // Check base model compatibility
  const availableModels = await ollamaClient.list();
  const baseModelAvailable = availableModels.some(m => m.name === entry.baseModel);
  if (!baseModelAvailable) {
    return reply.status(400).send({
      error: `Base model ${entry.baseModel} not installed. Run: ollama pull ${entry.baseModel}`,
    });
  }

  const destPath = await registryClient.downloadLoRA(
    entry,
    config.loraDir,
    (progress) => req.server.io.emit('install-progress', progress),
  );

  return reply.send({ success: true, path: destPath });
});

// POST /api/community/templates/publish
router.post('/community/templates/publish', async (req, reply) => {
  const { templatePath, githubToken } = req.body;
  const publisher = new TemplatePublisher(githubToken, validator);
  const result = await publisher.publish(templatePath);
  return reply.send(result);
});
```

---

## 6. Database Schema Changes

```sql
-- New tables for v1.0

-- Benchmark runs
CREATE TABLE benchmark_runs (
    id TEXT PRIMARY KEY,
    started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    completed_at DATETIME,
    suite TEXT NOT NULL,           -- 'quick', 'full', 'custom'
    config TEXT NOT NULL,          -- JSON: DebateConfig + benchmark params
    system_info TEXT NOT NULL,     -- JSON: HardwareInfo
    summary TEXT,                  -- JSON: BenchmarkSummary
    status TEXT DEFAULT 'running'  -- 'running', 'completed', 'failed', 'cancelled'
);

-- Individual benchmark question results
CREATE TABLE benchmark_results (
    id TEXT PRIMARY KEY,
    run_id TEXT NOT NULL REFERENCES benchmark_runs(id),
    question_id TEXT NOT NULL,
    domain TEXT NOT NULL,
    run_number INTEGER NOT NULL,
    answer TEXT NOT NULL,
    score REAL NOT NULL,
    scoring_details TEXT NOT NULL,  -- JSON
    duration_ms INTEGER,
    trace_id TEXT REFERENCES traces(id),
    UNIQUE(run_id, question_id, run_number)
);

-- Community installed items
CREATE TABLE community_installed (
    id TEXT PRIMARY KEY,           -- e.g., 'template:socratic-v1'
    type TEXT NOT NULL,            -- 'template' or 'lora'
    registry_id TEXT NOT NULL,
    version TEXT NOT NULL,
    installed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    local_path TEXT NOT NULL,
    checksum TEXT NOT NULL
);

-- Community ratings (local copy)
CREATE TABLE community_ratings (
    id TEXT PRIMARY KEY,
    registry_id TEXT NOT NULL,
    type TEXT NOT NULL,
    rating INTEGER NOT NULL CHECK(rating BETWEEN 1 AND 5),
    review TEXT,
    rated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_benchmark_results_run ON benchmark_results(run_id);
CREATE INDEX idx_benchmark_results_domain ON benchmark_results(domain);
CREATE INDEX idx_community_installed_type ON community_installed(type);
```

---

## 7. New Shared Types

```typescript
// packages/shared/types/v1.ts

// Benchmark types
export interface BenchmarkSummary {
  totalQuestions: number;
  completedQuestions: number;
  overallScore: number;
  byDomain: Record<BenchmarkDomain, DomainSummary>;
  comparedTo: Record<string, number>; // frontier model scores
}

export interface DomainSummary {
  domain: BenchmarkDomain;
  meanScore: number;
  stdDev: number;
  questionCount: number;
}

// Community types
export interface Registry {
  version: string;
  lastUpdated: string;
  templates: TemplateEntry[];
  loras: LoRAEntry[];
}

export interface TemplateEntry {
  id: string;
  name: string;
  author: string;
  authorUrl: string;
  version: string;
  domain: string;
  complexity: string;
  methodology: string;
  keywords: string[];
  description: string;
  downloadUrl: string;
  checksum: string;
  rating: number;
  ratingCount: number;
  downloadCount: number;
  publishedAt: string;
  updatedAt: string;
  license: string;
}

export interface LoRAEntry {
  id: string;
  name: string;
  author: string;
  authorUrl: string;
  version: string;
  baseModel: string;
  domain: string;
  description: string;
  huggingFaceRepo: string;
  checksum: string;
  sizeMb: number;
  rating: number;
  ratingCount: number;
  downloadCount: number;
  benchmarkScore?: number;
  publishedAt: string;
  updatedAt: string;
  license: string;
}

// Installer types
export interface HardwareInfo {
  ramGb: number;
  cpuCores: number;
  gpuVramGb: number | null;
  gpuType: 'nvidia' | 'amd' | 'apple-silicon' | 'intel-arc' | 'none';
  diskFreeGb: number;
  platform: 'darwin' | 'win32' | 'linux';
  arch: 'x64' | 'arm64';
}

export interface InstallProgress {
  type: 'step' | 'progress' | 'warning' | 'error' | 'complete';
  message: string;
  percent?: number;
}
```

---

## 8. CLI Changes

```typescript
// apps/cli/index.js (new commands)

// tmde benchmark run [--suite quick|full] [--domain math|science|logic|coding|research]
program
  .command('benchmark')
  .description('Run benchmark suite')
  .option('--suite <suite>', 'Benchmark suite: quick, full, or custom', 'quick')
  .option('--domain <domain>', 'Run only a specific domain')
  .option('--output <path>', 'Save results to file')
  .option('--resume <runId>', 'Resume a previous benchmark run')
  .action(async (options) => {
    const runner = new BenchmarkRunner(/* ... */);
    await runner.run(options, (progress) => {
      process.stdout.write(`\r${progress.message}`);
    });
  });

// tmde community browse [--type templates|loras] [--domain <domain>]
program
  .command('community browse')
  .description('Browse community hub')
  .option('--type <type>', 'Content type: templates or loras', 'templates')
  .option('--domain <domain>', 'Filter by domain')
  .action(async (options) => {
    const client = new RegistryClient(/* ... */);
    const items = await client.searchTemplates({ domain: options.domain });
    // Display as table
  });

// tmde community install <id>
program
  .command('community install <id>')
  .description('Install a template or LoRA from the community hub')
  .action(async (id) => {
    // Detect type from id prefix (template: or lora:)
    // Download and install
  });

// tmde publish template <path>
program
  .command('publish template <path>')
  .description('Publish a template to the community hub')
  .option('--token <token>', 'GitHub personal access token')
  .action(async (templatePath, options) => {
    const publisher = new TemplatePublisher(options.token, /* ... */);
    const result = await publisher.publish(templatePath);
    console.log(`Published! PR: ${result.prUrl}`);
  });

// tmde publish lora <path> --model <base-model>
program
  .command('publish lora <path>')
  .description('Publish a LoRA adapter to the community hub')
  .requiredOption('--model <model>', 'Base model name (e.g., qwen3:32b)')
  .option('--token <token>', 'GitHub personal access token')
  .option('--hf-token <token>', 'Hugging Face token')
  .action(async (loraPath, options) => {
    const publisher = new LoRAPublisher(options.token, options.hfToken, /* ... */);
    const result = await publisher.publish(loraPath, options.model);
    console.log(`Published! HF: ${result.hfUrl}, PR: ${result.prUrl}`);
  });
```

---

## 9. Environment Variables

```bash
# .env.example additions for v1.0

# Community Hub
COMMUNITY_REGISTRY_URL=https://raw.githubusercontent.com/tmde-community/registry/main/registry.json
COMMUNITY_CACHE_TTL=3600          # Seconds to cache registry (default: 1 hour)
GITHUB_TOKEN=                     # For publishing templates (optional)
HUGGINGFACE_TOKEN=                # For publishing LoRA adapters (optional)

# Benchmark
BENCHMARK_JUDGE_MODEL=llama3.3:70b
BENCHMARK_RUNS_PER_QUESTION=3
BENCHMARK_SEED=42

# Auto-update
AUTO_UPDATE_CHECK=true
AUTO_UPDATE_CHANNEL=stable         # stable, beta, nightly
```

---

## 10. Security Considerations

### 10.1 Installer Security

- All installers are code-signed (macOS: Apple Developer cert, Windows: EV cert)
- SHA-256 checksums published alongside installers on GitHub Releases
- Installer downloads Ollama from official source only (hardcoded URL, verified checksum)
- No installer telemetry without explicit opt-in

### 10.2 Community Hub Security

- Templates are validated to not contain executable code before installation
- LoRA adapters use safetensors format (safe by design — no arbitrary code execution)
- Registry is hosted on GitHub (trusted, auditable, version-controlled)
- All downloads verified against checksums from registry
- Content moderation via GitHub issues (report button → creates issue)
- Rate limiting on publish API to prevent spam

### 10.3 Benchmark Security

- Benchmark questions are read-only (no user modification of core suite)
- LLM judge runs locally (no data sent to external services)
- Results are stored locally only (opt-in sharing to community leaderboard)

---

## 11. Migration Guide

Since v1.0 builds on v0.4, no breaking changes are introduced. The following additions require attention:

1. **New packages:** `packages/benchmark` and `packages/community` must be added to the monorepo workspace
2. **Database migration:** Run migration script to add new tables (`benchmark_runs`, `benchmark_results`, `community_installed`, `community_ratings`)
3. **New environment variables:** Copy new variables from `.env.example` to `.env`
4. **PWA assets:** Generate and add PWA icons (192x192, 512x512) to `apps/web/public/icons/`
5. **next-pwa:** Install `next-pwa` package in `apps/web`
